# Functional overview

The project involves two general flows:
1. Extraction
2. Conversion

Let's first break down each of these separately.

### 1. Extraction

Here's a simplified view of this flow:

```
                               detecting
     extracting                 parameter
      values \                   types
              \                    |
.---------.   |   .-----------.    |     .--------------.
| tfstate |------>| XResource |--------->| XRDefinition |
`---------'       `-----------'          `--------------'
  (input)                   \               /
                             `- (outputs) -'
```

To put it in words:
1. Our only input is the terraform state[^1], which includes all terraform provider resources.
2. We transform it by extracting all module arguments and attributes (the `values`) - these become our new `CompositeResources` (or `XResources` or `XRs` for short).
3. Types of each extracted `value` are automatically detected, which leads to constructing resource schemas (`CustomResourceDefinitions` or `XRDefinitions` or `XRDs` for short).

All the above is done by transforming json files with `jq`. So the result of the *Extraction* flow is two sets of json files: `XRs` and `XRDs`[^2], representing the terraform resources.


### 2. Translation

Having `XRs` and `XRDs`, we can run `kubectl apply` to create kubernetes objects - but these are of no practical use until we can convert them to something that a crossplane provider understands. So now we need to *translate* our "raw" `XRs` into the `XRs` defined by the target crossplane provider. How to do that? Well, crossplane already provides a mechanism for such conversions: this is what `Compositions` do!

Let's have a look how that's achieved:

```

.-----------.             .- - - - - - - .
| XResource | . . . . . . : XRDefinition :
`-----------'             `- - - - - - - '
       |                          |
       v      (1)                 v      (2)
  .=============.     helm   .-------------.
  | Composition | <----------| translation | (input)
  `============='             \  config   /
       |                       `---------'
       |                          ^
       v                          |
.------------.           .- - - - - - - - .
| crossplane | . . . . . :   crossplane   :
|  resource  |           : provider's CRD :
`------------'           `- - - - - - - - '
```

Ok, this may look a little bit more complicated at first, but that's just because we have included the two contextual elements for completeness (the `XRD` and `CRD`). The middle part is what matters here, specifically:
1. The `Composition` - that's what does the whole magic of translating our "raw resource" (extracted in the first stage) into a *crossplane resource*.
2. A *translation config* file - this is the only additional input at this stage. Basically, it's a helm values file, where we define the parameter mapping between terraform and crossplane side, in a concise manner. Why? Simply because writing `Compositions` manually can be a bit confusing and error-prone.

The final *crossplane resource* at the bottom is what our crossplane provider understands and manages. Once that is generated by the `Composition`, our infrastructure becomes managed by crossplane[^3]!


# Support tooling

Let's now have a look at some of the accompanying tooling, which facilitates common tasks around the use of `deform`. Most of it is currently written in `bash`... Because.


## generating *translation configs*

OK, but let's say we have extracted 10 types of terraform resources from our tfstate, with an average of 10 parameters defined. This would mean that, in order to give crossplane control over our infrastructure, we would need to define a total of 100 `fromFieldPath` and `toFieldPath` pairs in our `Compositions` (via the *translation config*)! That's way too much work, completely impractical.

Luckily this can be mostly automated as well. If you look at the documentation of any terraform provider resource and compare it with a corresponding crossplane provider resource, you will notice a recurring pattern: In **most** cases, the parameter names for both terraform and crossplane are composed of the **same words** - the only difference being, crossplane uses camel case, while terraform uses underscores. So `network_border_group` becomes `networkBorderGroup` etc. This can be automatically identified by comparing provider specifications - and that's what the helper function `prep_provider` does.

So the majority of the translation definition (conversion config) is generated automatically. The `prep_provider` function generates configuration files based on three input data sources:
1. a set of terraform resources (obtained from the `tfstate`),
2. crossplane CRD for the selected provider (downloaded from (https://doc.crds.dev)),
3. terraform provider documentation (extracted from corresponding (https://github.com/terraform-providers/) git repo).

Since in practice not all parameter translations can be determined automatically, the config files generated by `prep_provider` function may need manual inspection/tuning. To indicate this, each generated config file is marked as Work In Progress (WIP) by adding an `_edit_` prefix to its name.

----
[^1]: More precisely, we use the standardized json format obtained by running `terraform show -json [input tfstate]`. That's because it has been declared by Hashicorp as standardized, as opposed to the raw `tfstate` file. In more recent versions, terraform is said to have standardized the format of `tfstate` as well, so in the future `deform` could potentially switch to using `tfstate` directly.
[^2]: `deform` calls these "raw XRs" and "raw XRD", respectively. This is to indicate the fact that they directly mimic the structure of corresponding terraform provider module.
[^3]: Assuming you have configured your crossplane provider correctly with your target cloud provider.
