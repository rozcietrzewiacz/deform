# Functional overview

The project involves two general flows:
1. Extraction
2. Conversion

Let's first break down each of these separately.

### 1. Extraction

Here's a simplified view of this flow:

```
                               detecting
     extracting                 parameter
      values \                   types
              \                    |
.---------.   |   .-----------.    |     .--------------.
| tfstate |------>| XResource |--------->| XRDefinition |
`---------'       `-----------'          `--------------'
  (input)                   \               /
                             `- (outputs) -'
```

To put it in words:
1. Our only input is the terraform state[^1], which includes all terraform provider resources.
2. We transform it by extracting all module arguments and attributes (the `values`) - these become our new `CompositeResources` (or `XResources` or `XRs` for short).
3. Types of each extracted `value` are automatically detected, which leads to constructing resource schemas (`CustomResourceDefinitions` or `XRDefinitions` or `XRDs` for short).

All the above is done by transforming json files with `jq`. So the result of the *Extraction* flow is two sets of json files: `XRs` and `XRDs`[^2], representing the terraform resources.


### 2. Translation

Having `XRs` and `XRDs`, we can run `kubectl apply` to create kubernetes objects - but these are of no practical use until we can convert them to something that a crossplane provider understands. So now we need to *translate* our "raw" `XRs` into the `XRs` defined by the target crossplane provider. How to do that? Well, crossplane already provides a mechanism for such conversions: this is what `Compositions` do!

Let's have a look how that's achieved:

```

.-----------.             .- - - - - - - .
| XResource | . . . . . . : XRDefinition :
`-----------'             `- - - - - - - '
       |                          |
       v      (1)                 v      (2)
  .=============.     helm   .-------------.
  | Composition | <----------| translation | (input)
  `============='             \  config   /
       |                       `---------'
       |                          ^
       v                          |
.------------.           .- - - - - - - - .
| crossplane | . . . . . :   crossplane   :
|  resource  |           : provider's CRD :
`------------'           `- - - - - - - - '
```

This may look a little bit more complicated at first, but that's just because we have included the two contextual elements for completeness (the `XRD` and `CRD`). The middle part is what matters here, specifically:
1. The `Composition` - that's what does the whole magic of translating our "raw resource" (extracted in the first stage) into a *crossplane resource*.
2. A *translation config* file - this is the only additional input at this stage. Basically, it's a helm values file, where we define the parameter mapping between terraform and crossplane side, in a concise manner. Why? Simply because writing `Compositions` manually can be a bit confusing and error-prone.

The final *crossplane resource* at the bottom is what our crossplane provider understands and manages. Once that is generated by the `Composition`, our infrastructure becomes managed by crossplane[^3]!


# Support tooling

Let's now have a look at some of the accompanying tooling, which facilitates common tasks around the use and development of `deform`. Most of it is currently written in `bash`... Because.

Most of the tooling is provided in the form of shell functions. To use them, you need to source `helpers.sh`:

```
source helpers.sh
```

## generating *translation configs*

OK, so let's say we have extracted 10 types of terraform resources from our tfstate, with an average of 10 parameters defined. This would mean that, in order to give crossplane control over our infrastructure, we would need to define a total of 100 `fromFieldPath` and `toFieldPath` pairs in our `Compositions` (via the *translation config*)! That's way too much work, completely impractical.

Luckily this can be mostly automated as well. If you look at the documentation of any terraform provider resource and compare it with a corresponding crossplane provider resource, you will notice a recurring pattern: In **most** cases, the parameter names for both terraform and crossplane are composed of the **same words** - the only difference being, crossplane uses camel case, while terraform uses underscores. So `network_border_group` becomes `networkBorderGroup` etc. This can be automatically identified by comparing provider specifications - and that's what the helper function `generate_translation_configs` does.

So the majority of the translation definition (conversion config) is generated automatically. The `generate_translation_configs` function generates configuration files based on three input data sources:
1. A set of terraform resources (obtained from the `tfstate`),
2. (*) Crossplane CRD for the selected provider (downloaded from (https://doc.crds.dev)),
3. (*) Terraform provider documentation (extracted from corresponding (https://github.com/terraform-providers/) git repo).

As you can see, the list incudes two external resources. Those need to be cached locally - the `populate_provider_cache.sh` script does this for us. _Note: supported provider versions are currently **hardcoded** inside the script:_

```
./populate_provider_cache.sh $PROVIDER
```

Once the `.cache` is populated, you are ready to run:
```
generate_translation_configs in/path/my/terraform-state-show.json
```

Since in practice not all parameter translations can be determined automatically, the config files generated by `generate_translation_configs` function may need manual inspection/tuning. To indicate this, each generated config file is marked as Work In Progress (WIP) by adding an `_edit_` prefix to its name.

The function attempts to identify matching provider resource kinds based on resource name pattern. In case no such match is found, `fzf` is invoked, which allows the user to search for matching crossplane resource kind manually. If you can't find a match, exit `fzf` with `Ctrl+C` and the input terraform resource type will be marked as unsupported by creating and empty translation config file with a `_missing_` prefix.

`//TODO: The interface of fzf may need more explanation`


## identifying coverage of the translation configs

Before you decide whether to use `deform` against your `tfstate`, it is useful to know how many of your terraform resources are currently translatable. The `helpers.sh` provides two functions to characterize the current coverage:

 * **`cover $PROVIDER in/path/my/terraform-state-show.json`** will list all identifiable "raw" resources for a given `$PROVIDER` within your `json` file, as well as inform about the number of each of those and current support state. The last column indicates support state, which can be either:
    - full support - indicated by the name of identified translation config yaml,
    - work in progress (`WIP`) - based on the existence of translation file prefixed with `_edit_`, such as the aforementioned `generate_translation_configs` function creates,
    - `UNSUPPORTED` - indicating that the `generate_translation_configs` was already run and no corresponding resource was found in the specific crossplane provider[^4],
    - `UNKNOWN` - this means that no matching translation config file was found in the `$PROVIDER/` directory. You're welcome to `generate_translation_configs` and check if a translation can be already determined.
 * **`cover_stats $PROVIDER in/some/set/of/files/* [...]`** lists how many resource types are identified in each support class, in each of the supplied files. You can optionally ask the function to report exact _resource _count_ instead of just counting distinct _kinds_ of resources. For that, you'd use the `-r` parameter: `cover_stats $PROVIDER -r in/some/set/of/files/* [...]`.

----

### [footnotes]

[^1]: More precisely, we use the standardized json format obtained by running `terraform show -json [input tfstate]`. That's because it has been declared by Hashicorp as standardized, as opposed to the raw `tfstate` file. In more recent versions, terraform is said to have standardized the format of `tfstate` as well, so in the future `deform` could potentially switch to using `tfstate` directly.
[^2]: `deform` calls these "raw XRs" and "raw XRD", respectively. This is to indicate the fact that they directly mimic the structure of corresponding terraform provider module.
[^3]: Assuming you have configured your crossplane provider correctly with your target cloud provider.
[^4]: Note that this 
